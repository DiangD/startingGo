package main

import (
	"fmt"
	"sync"
)

//$ go build -gcflags '-m' ./escape.go
//# command-line-arguments
//.\escape.go:13:6: can inline buildUserArr
//.\escape.go:36:6: can inline printUser
//.\escape.go:37:13: inlining call to fmt.Println
//.\escape.go:23:21: inlining call to buildUserArr
//.\escape.go:29:13: inlining call to printUser
//.\escape.go:29:13: inlining call to fmt.Println
//.\escape.go:30:11: inlining call to sync.(*WaitGroup).Done
//.\escape.go:14:15: []user literal escapes to heap
//.\escape.go:28:11: leaking param: u
//.\escape.go:24:6: moved to heap: wg
//.\escape.go:27:3: moved to heap: tmp
//.\escape.go:23:21: []user literal does not escape
//.\escape.go:28:6: func literal escapes to heap
//.\escape.go:29:13: []interface {} literal does not escape
//.\escape.go:36:16: leaking param: user
//.\escape.go:37:13: []interface {} literal does not escape
//<autogenerated>:1: .this does not escape
//<autogenerated>:1: .this does not escape

type user struct {
	username string
	password string
}

func buildUserArr() []user {
	return []user{
		{username: "qzh", password: "123"},
		{username: "gfh", password: "12345"},
		{username: "ff", password: "12345"},
		{username: "srw", password: "12345"},
	}
}

// u在调用过程中会逃逸到堆(在协程引用了别的协程的变量，变量逃逸到heap)，
//因此u不会随着函数结束而消亡
func wrong(arr []user) {
	for _, u := range arr {
		go func(u *user) {
			printUser(u)
		}(&u)
	}
}

func main() {
	arr := buildUserArr()
	var wg sync.WaitGroup
	wg.Add(len(arr))
	for _, u := range arr {
		tmp := u
		go func(u *user) {
			printUser(u)
			wg.Done()
		}(&tmp)
	}
	wg.Wait()
}

func printUser(user *user) {
	fmt.Println(user)
}
